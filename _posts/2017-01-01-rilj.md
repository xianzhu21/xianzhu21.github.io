---
layout: post
title: "RIL的服务机制"
date: 2017-08-08 00:00:00
tags: [Android]
categories: [I'm a coder]
# excerpt: 介绍了Android中RILJ的req/resp和ind服务的机制，服务中使用的RILRequest数据结构与RILRegistrant的机制
description: 介绍了Android中RILJ的req/resp和ind服务的机制，服务中使用的RILRequest数据结构与RILRegistrant的机制
---
<!-- more -->
> 欢迎转载，转载请注明出处 [xianzhuliu.github.io](xianzhuliu.github.io)。

## RIL简介

RIL(Radio Interface Layer)是一种HAL(Hardware Abstraction Layer)，它提供控制Modem的统一接口。而RILJ是一种给Java层提供与RIL通信的Android Framework层服务。RILJ通过Unix Socket与RIL守护进程通信，可以说RILJ是Telephony框架中Java层的最底层。

RILJ有2种服务机制——req/resp和ind服务。因为网络服务需要异步操作，RILJ中有2个线程——RILSender和RILReceiver，分别处理向RIL守护程序发送数据和从RIL守护程序接收数据。

## req/resp服务机制

req/resp服务机制的流程是
1. 客户端发送特定类型的Message对象给RILJ
2. RILJ用Message对象生成RILRequest对象，发送给RILSender线程
3. RILSender线程先把RILRequest对象加到RILRequest List，然后将RILRequest对象的数据序列化后用Socket发送给RIL守护进程
4. RILReceiver接收RIL守护进程发送的结果，并从RILRequest List中找到相应的RILRequest，取出客户端发送的Message对象，把结果存到Message对象中并发送给客户端的Handler对象
5. 客户端的Handler对象根据Message对象类型处理结果

下面结合源码一一分析每一个步骤。以Android 6源码分析，但Android 4, 5, 6的MO在RIL部分的代码基本没有改变。

<figure>
    <a href="/images/mof.jpg"><img src="/images/mof.jpg" alt="MO in Framework"></a>
    <figcaption>MO in Framework</figcaption>
</figure>

上图是MO (Mobile Origination, 即拨打电话) 在Framework层的时序图。

### 1. 客户端发送给RILJ

首先Phone (GsmPhone为例，CdmaPhone类似) 对象调用GsmCallTracker (继承自Handler)对象的dial，GsmCallTracker对象调用CommandInterface对象 (即RIL对象) 的dial方法。

{% highlight java linenos %}
/* GsmCallTacker.java */
synchronized Connection dial (String dialString, int clirMode, UUSInfo uusInfo, Bundle intentExtras)
        throws CallStateException {
    // ...
    // 调用CommandInterface对象，即RIL对象的dial()方法
    // obtainCompleteMessage(EVENT_DIAL_CALL_RESULT)方法是获取
    // msg.what为EVENT_DIAL_CALL_RESULT的Message对象
    mCi.dial(mPendingMO.getAddress(), clirMode, uusInfo,
            obtainCompleteMessage(EVENT_DIAL_CALL_RESULT));
    // ...
}
{% endhighlight %}

### 2. RILJ发送给RILSender线程

接下来分析RIL的dial方法。

{% highlight java linenos %}
/* RIL.java */
@Override
public void dial(String address, int clirMode, UUSInfo uusInfo, Message result) {
    // 获取RILRequest对象，包含客户端传递的Message对象
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_DIAL, result);
    // 写入数据
    rr.mParcel.writeString(address);
    rr.mParcel.writeInt(clirMode);
    // ...
    send(rr);
}
{% endhighlight %}

RIL的dial方法中利用GsmCallTracker传递过来的Message对象获取RILRequest对象。RILRequest类主要有4个成员变量。```int mSerial```是用来唯一标识RILRequest对象的变量，```int mRequest```是RILSender用于区分RILRequest类型的变量，MO中为RIL_REQUEST_DIAL，```Message mResult```是存储结果的Message对象，是从GsmCallTracker传递过来的，```Parcel mParcel```是存储请求数据的Parcel对象。

{% highlight java linenos %}
/* RIL.java */
static RILRequest obtain(int request, Message result) {
    RILRequest rr = null;
    synchronized(sPoolSync) {
        if (sPool != null) {
            rr = sPool;
            sPool = rr.mNext;
            rr.mNext = null;
            sPoolSize--;
        }
    }
    if (rr == null) {
        rr = new RILRequest();
    }
    // 唯一序列号
    rr.mSerial = sNextSerial.getAndIncrement();
    // RILRequest类型
    rr.mRequest = request;
    // 用来保存结果的Message对象，从客户端传递过来
    rr.mResult = result;
    // 获取用来存储请求数据的Parcel对象
    rr.mParcel = Parcel.obtain();
    if (result != null && result.getTarget() == null) {
        throw new NullPointerException("Message target must not be null");
    }
    // first elements in any RIL Parcel
    rr.mParcel.writeInt(request);
    rr.mParcel.writeInt(rr.mSerial);
    return rr;
}
{% endhighlight %}

接下来调用RIL的send方法，传递刚获取到的RILRequest对象。send方法将RILRequest对象存到Message对象后发送给RILSender处理。

{% highlight java linenos %}
/* RIL.java */
private void send(RILRequest rr) {
    Message msg;
    if (mSocket == null) {
        rr.onError(RADIO_NOT_AVAILABLE, null);
        rr.release();
        return;
    }
    // 获取RILSender的Message对象
    msg = mSender.obtainMessage(EVENT_SEND, rr);
    acquireWakeLock();
    // Message对象发送给RILSender对象
    msg.sendToTarget();
}
{% endhighlight %}

### 3. RILSender线程发送给RIL守护进程

接下来我们来分析RILSender的工作机制。

RILSender继承自Handler，实现了Runnable接口。RIL在构造方法中创建HandlerThread线程来执行RILSender。

{% highlight java linenos %}
/* RIL.java */
public RIL(Context context, int preferredNetworkType, int cdmaSubscription, Integer instanceId) {
    // ...
    mSenderThread = new HanlderThread("RILSender" + mInstanceId);
    mSenderThread.start();

    Looper looper = mSenderThread.getLooper();
    mSender =  new RILSender(looper);
    // ...
}
{% endhighlight %}

RILSender接收RIL发送的Message对象后在handleMessage方法中处理RILRequest对象，然后利用RILReceiver创建的LocalSocket对象把RIL req数据发送给RIL守护进程。

{% highlight java linenos %}
/* RIL.java */
class RILSender extends Handler implements Runnable {
    public RILSender(Looper looper) {
        super(looper);
    }

    @Override
    public void handleMessage(Message msg) {
        // 从Message对象取RILRequest对象
        RILRequest rr = (RILRequest)(msg.obj);
        // ...

        switch (msg.what) {
            case EVENT_SEND:
                try {
                    LocalSocket s;
                    // mSocket为RILReceiver创建的LocalSocket对象
                    s = mSocket;
                    // ...
                    byte[] data;
                    // 对Parcel对象编组，以便用Socket发送给RILC
                    data = rr.mParcel.marshall();
                    // 把RILRequest对象加入到RILRequest List，以便RIL resp服务查找
                    synchronized (mRequestList) {
                        mRequestList.append(rr.mSerial, rr);
                        rr.mParcel.recycle();
                        rr.mParcel = null;
                    }
                    // ...
                    // parcel length in big endan
                    dataLength[0] = dataLength[1] = 0;
                    dataLength[2] = (byte)((data.length >> 8) & 0xff);
                    dataLength[3] = (byte)((data.length) & 0xff);

                    // 发送给RIL守护进程
                    s.getOutputStream().write(dataLength);
                    s.getOutputStream().write(data);
                } // catch ...
                break;
            // ...
        }
    }
}
{% endhighlight %}

### 4. RILReceiver接收RIL守护进程发送的结果，处理后发送给客户端的Handler

首先从socket中读取数据，然后根据类型（resp服务或ind服务）处理。从mRequestList中根据serial值取出RILRequest对象并删除。然后从RILRequest对象中取出客户端的Message对象，把rild返回的数据存到Message对象中，然后发送给客户端来处理返回的数据。

{% highlight java linenos %}
/* RIL.java */
class RILReceiver implements Runnable {
    byte[] buffer;
    // ...
    @Override
    public void
    run() {
        //...
        try {
            // 连接rild的socket
            s = new LocalSocket();
            l = new LocalSocketAddress(rilSocket,
                    LocalSocketAddress.Namespace.RESERVED);
            s.connect(l);
        } catch (IOException ex){
            // ...
        }
        // 把socket保存到mSocket成员变了，共RILSender调用
        mSocket = s;
        // ...
        int length = 0;
        try {
            InputStream is = mSocket.getInputStream();
            for (;;) {
                Parcel p;
                // 从socket中读取数据存到buffer
                length = readRilMessage(is, buffer);
                if (length < 0) {
                    // End-of-stream reached
                    break;
                }
                // 把数据反编组保存到Parcel对象中
                p = Parcel.obtain();
                p.unmarshall(buffer, 0, length);
                p.setDataPosition(0);

                //Rlog.v(RILJ_LOG_TAG, "Read packet: " + length + " bytes");
                // 处理数据
                processResponse(p);
                p.recycle();
            }
        } // catch {}
        // ...
    }
}

private void processResponse (Parcel p) {
    int type;
    type = p.readInt();
    if (type == RESPONSE_UNSOLICITED) {
        // 处理ind服务，即rild自发发送的数据
        processUnsolicited (p);
    } else if (type == RESPONSE_SOLICITED) {
        // 处理resp服务，即请求rild后返回的数据
        RILRequest rr = processSolicited (p);
        if (rr != null) {
            rr.release();
            decrementWakeLock();
        }
    }
}

private RILRequest processSolicited (Parcel p) {
    int serial, error;
    boolean found = false;

    serial = p.readInt();
    error = p.readInt();

    RILRequest rr;
    // 在mRequestList中取出RILRequest对象，然后删除
    rr = findAndRemoveRequestFromList(serial);
    // ...
    if (error == 0 || p.dataAvail() > 0) {
        try {switch (rr.mRequest) {
        // ...
        // responseVoid方法中直接返回null
        case RIL_REQUEST_DIAL: ret =  responseVoid(p); break;
        // ...
        }} // catch {}
    }
    // ...
    if (error == 0) {
        if (rr.mResult != null) {
            // 处理RILRequest对象的数据
            // 用AsyncResult对象包一下m.obj和ret然后再赋给m.obj
            /*
            public static AsyncResult
            forMessage(Message m, Object r, Throwable ex) {
                AsyncResult ret;
                ret = new AsyncResult (m.obj, r, ex);
                m.obj = ret;
                return ret;}
            */
            AsyncResult.forMessage(rr.mResult, ret, null);
            // 发送给客户端的Handler对象来处理
            rr.mResult.sendToTarget();
        }
    }
    return rr;
}
{% endhighlight %}

### 5. 客户端的Handler对象根据Message对象类型处理结果

GsmCallTracker对象处理返回的Message对象

{% highlight java linenos %}
/* GsmCallTracker.java */
@Override
public void handleMessage (Message msg) {
    AsyncResult ar;
    // ...
    switch (msg.what) {
        // ...
        case EVENT_DIAL_CALL_RESULT:
            ar = (AsyncResult) msg.obj;
            if (ar.exception != null) {
                log("dial call failed!!");
                mHelper.PendingHangupRequestUpdate();
            }
            operationComplete();
        break;
        // ...
    }
}
{% endhighlight %}

RILJ的req/resp服务的整个流程如下图所示。
<figure>
    <a href="/images/RIL_req_resp.png"><img src="/images/RIL_req_resp.png" alt="RIL req/resp"></a>
    <figcaption>RIL req/resp service</figcaption>
</figure>

## ind服务机制

ind服务机制的流程是
1. RILReceiver从rild获得消息，然后在processUnsolicited方法中根据reponse类型获得底层传过来的数据。
2. 再根据response类型，调用相应的Registrant对象的notifyRegistrant方法或RegistrantList对象的notifyRegistrants方法。
3. 把数据封装成AsyncResult对象，发送给相应的注册对象。

我们以来电为例来说明ind服务的流程。

### 1. RILReceiver获取rild发来的消息

第一步跟req/resp服务中RILReceiver接收消息的代码一致，在processResponse方法中ind服务的消息会调用processUnsolicited方法。这里不再赘述。

### 2. 调用相应的Registrant对象的notifyRegistrant方法

下面的代码是processUnsolicited方法的处理过程，最后会调用mRingRegistrant的notifyRegistrant方法。

{% highlight java linenos %}
/* RIL.java */
private void processUnsolicited (Parcel p) {
    int response;
    Object ret;

    response = p.readInt();

    try {switch(response) {
        // ...
        // 从Pacel对象中获取数据，保存在char数组中
        case RIL_UNSOL_CALL_RING: ret =  responseCallRing(p); break;

    }} // catch

    switch(response) {
        // ...
        case RIL_UNSOL_CALL_RING:
                if (RILJ_LOGD) unsljLogRet(response, ret);

                if (mRingRegistrant != null) {
                    // mRingRegistrant不空说明有注册对象，调用notifyRegistrant方法来通知注册对象
                    mRingRegistrant.notifyRegistrant(new AsyncResult (null, ret, null));
                }
                break;
        // ...
    }
}
{% endhighlight %}

mRingRegistrant是Registrant对象，Registrant机制其实是订阅者模式。RIL继承自BaseCommand类，Registrant对象和RegistrantList对象是在BaseCommand中创建的，因此RIL类也拥有mRingRegistrant。

### 3. 把数据发送给相应的注册对象

在这里首先说明Registrant的机制，先看下Registrant类的代码。

{% highlight java linenos %}
/* Registrant.java */
public class Registrant
{
    public Registrant(Handler h, int what, Object obj)
    {
        refH = new WeakReference(h);
        this.what = what;
        userObj = obj;
    }

    // 这个方法还有其他3个方法重载，参数分别是空、Object对象和Throwable对象
    public void notifyRegistrant(AsyncResult ar)
    {
        internalNotifyRegistrant (ar.result, ar.exception);
    }

    /*package*/ void internalNotifyRegistrant (Object result, Throwable exception)
    {
        Handler h = getHandler();

        if (h == null) {
            clear();
        } else {
            Message msg = Message.obtain();
            msg.what = what;
            msg.obj = new AsyncResult(userObj, result, exception);
            h.sendMessage(msg); // 把数据给注册对象的Handler发送Message
        }
    }

    public Handler getHandler()
    {
        if (refH == null)
            return null;

        return (Handler) refH.get();
    }

    // 拥有3个成员变量，它们的值都是构造方法中注册对象传递过来的
    WeakReference   refH; // 存储Handler对象的弱引用
    int             what; // 注册对象用来区分不同的Registrant对象，注册对象可能会注册很多Registrant
    Object          userObj;
}
{% endhighlight %}

RegistrantList类跟Registrant类似，该类中有一个ArrayList，每注册一次就创建一个Registrant对象后加入到ArrayList中，而internalNotifyRegistrants方法中遍历调用每个Registrant对象的internalNotifyRegistrant方法。

接下来看一下mRingRegistrant的注册方法，在BaseCommand类中。

{% highlight java linenos %}
/* BaseCommand.java */
// 很简单的一个方法，就是用注册对象的三个变量把mRingRegistrant实例化
@Override
public void setOnCallRing(Handler h, int what, Object obj) {
    mRingRegistrant = new Registrant (h, what, obj);
}

@Override
public void unSetOnCallRing(Handler h) {
    if (mRingRegistrant != null && mRingRegistrant.getHandler() == h) {
        mRingRegistrant.clear();
        mRingRegistrant = null;
    }
}
{% endhighlight %}

PhoneBase类在构造方法中注册了mRingRegistrant。

{% highlight java linenos %}
/* PhoneBase.java */
protected PhoneBase(String name, PhoneNotifier notifier, Context context, CommandsInterface ci,
            boolean unitTestMode, int phoneId) {
    // ...
    mCi = ci;
    // 注册mRingRegistrant
    mCi.setOnCallRing(this, EVENT_CALL_RING, null);
    // ...
}

@Override
public void handleMessage(Message msg) {
    AsyncResult ar;
    // ...
    switch(msg.what) {
        // 在handleMessage方法中处理mRingRegistrant发送的消息
        case EVENT_CALL_RING:
            Rlog.d(LOG_TAG, "Event EVENT_CALL_RING Received state=" + getState());
            ar = (AsyncResult)msg.obj;
            if (ar.exception == null) {
                PhoneConstants.State state = getState();
                if ((!mDoesRilSendMultipleCallRing)
                        && ((state == PhoneConstants.State.RINGING) ||
                                (state == PhoneConstants.State.IDLE))) {
                    mCallRingContinueToken += 1;
                    sendIncomingCallRingNotification(mCallRingContinueToken);
                } else {
                    notifyIncomingRing();
                }
            }
            break;
        // ...
    }
}
{% endhighlight %}

ind服务机制就是客户端注册Registrant，RILReceiver接收消息后调用相应的Registrant.notifyRegistrant方法，在该方法中把消息发送给客户端的Handler，最终在客户端的handleMessge方法中处理消息。流程图如下所示。

<figure>
    <a href="/images/RIL_ind.png"><img src="/images/RIL_ind.png" alt="RIL ind"></a>
    <figcaption>RIL ind service</figcaption>
</figure>

to be continued...
