---
layout: post
title: "RIL的服务机制"
date: 2017-01-01 00:00:00
tags: [Android]
categories: [I'm a coder]
# excerpt: 介绍了Android中RILJ的req/resp和ind服务的机制，服务中使用的RILRequest数据结构与RILRegistrant的机制
description: 介绍了Android中RILJ的req/resp和ind服务的机制，服务中使用的RILRequest数据结构与RILRegistrant的机制
---
<!-- more -->
> 欢迎转载，转载请注明出处 [xianzhuliu.github.io](xianzhuliu.github.io)。

## RIL简介

RIL(Radio Interface Layer)是一种HAL(Hardware Abstraction Layer)，它提供控制Modem的统一接口。而RILJ是一种给Java层提供与RIL通信的Android Framework层服务。RILJ通过Unix Socket与RIL守护进程通信，可以说RILJ是Telephony框架中Java层的最底层。

RILJ有2种服务机制——req/resp和ind服务。因为网络服务需要异步操作，RILJ中有2个线程——RILSender和RILReceiver，分别处理向RIL守护程序发送数据和从RIL守护程序接收数据。

## req/resp服务机制

req/resp服务机制的流程是
1. 客户端发送特定类型的Message对象给RILJ
2. RILJ用Message对象生成RILRequest对象，发送给RILSender线程
3. RILSender线程先把RILRequest对象加到RILRequest List，然后将RILRequest对象的数据序列化后用Socket发送给RIL守护进程
4. RILReceiver接收RIL守护进程发送的结果，并从RILRequest List中找到相应的RILRequest，取出客户端发送的Message对象，把结果存到Message对象中并发送给客户端的Handler对象
5. 客户端的Handler对象根据Message对象类型处理结果

下面结合源码一一分析每一个步骤。以Android 6源码分析，但Android 4, 5, 6的MO在RIL部分的代码基本没有改变。

<figure>
    <a href="/images/mof.jpg"><img src="/images/mof.jpg" alt="MO in Framework"></a>
    <figcaption>MO in Framework</figcaption>
</figure>

上图是MO (Mobile Origination, 即拨打电话) 在Framework层的时序图。

### 1. 客户端发送给RILJ

首先Phone (GsmPhone为例，CdmaPhone类似) 对象调用GsmCallTracker (继承自Handler)对象的dial，GsmCallTracker对象调用CommandInterface对象 (即RIL对象) 的dial方法。

{% highlight java linenos %}
/* GsmCallTacker.java */
synchronized Connection dial (String dialString, int clirMode, UUSInfo uusInfo, Bundle intentExtras)
        throws CallStateException {
    // ...
    // 调用CommandInterface对象，即RIL对象的dial()方法
    // obtainCompleteMessage(EVENT_DIAL_CALL_RESULT)方法是获取
    // msg.what为EVENT_DIAL_CALL_RESULT的Message对象
    mCi.dial(mPendingMO.getAddress(), clirMode, uusInfo,
            obtainCompleteMessage(EVENT_DIAL_CALL_RESULT));
    // ...
}
{% endhighlight %}

### 2. RILJ发送给RILSender线程

接下来分析RIL的dial方法。

{% highlight java linenos %}
/* RIL.java */
@Override
public void dial(String address, int clirMode, UUSInfo uusInfo, Message result) {
    // 获取RILRequest对象，包含客户端传递的Message对象
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_DIAL, result);
    // 写入数据
    rr.mParcel.writeString(address);
    rr.mParcel.writeInt(clirMode);
    // ...
    send(rr);
}
{% endhighlight %}

RIL的dial方法中利用GsmCallTracker传递过来的Message对象获取RILRequest对象。RILRequest类主要有4个成员变量。```int mSerial```是用来唯一标识RILRequest对象的变量，```int mRequest```是RILSender用于区分RILRequest类型的变量，MO中为RIL_REQUEST_DIAL，```Message mResult```是存储结果的Message对象，是从GsmCallTracker传递过来的，```Parcel mParcel```是存储请求数据的Parcel对象。

{% highlight java linenos %}
/* RIL.java */
static RILRequest obtain(int request, Message result) {
    RILRequest rr = null;
    synchronized(sPoolSync) {
        if (sPool != null) {
            rr = sPool;
            sPool = rr.mNext;
            rr.mNext = null;
            sPoolSize--;
        }
    }
    if (rr == null) {
        rr = new RILRequest();
    }
    // 唯一序列号
    rr.mSerial = sNextSerial.getAndIncrement();
    // RILRequest类型
    rr.mRequest = request;
    // 用来保存结果的Message对象，从客户端传递过来
    rr.mResult = result;
    // 获取用来存储请求数据的Parcel对象
    rr.mParcel = Parcel.obtain();
    if (result != null && result.getTarget() == null) {
        throw new NullPointerException("Message target must not be null");
    }
    // first elements in any RIL Parcel
    rr.mParcel.writeInt(request);
    rr.mParcel.writeInt(rr.mSerial);
    return rr;
}
{% endhighlight %}

接下来调用RIL的send方法，传递刚获取到的RILRequest对象。send方法将RILRequest对象存到Message对象后发送给RILSender处理。

{% highlight java linenos %}
/* RIL.java */
private void send(RILRequest rr) {
    Message msg;
    if (mSocket == null) {
        rr.onError(RADIO_NOT_AVAILABLE, null);
        rr.release();
        return;
    }
    // 获取RILSender的Message对象
    msg = mSender.obtainMessage(EVENT_SEND, rr);
    acquireWakeLock();
    // Message对象发送给RILSender对象
    msg.sendToTarget();
}
{% endhighlight %}

### 3. RILSender线程发送给RIL守护进程

接下来我们来分析RILSender的工作机制。

RILSender继承自Handler，实现了Runnable接口。RIL在构造方法中创建HandlerThread线程来执行RILSender。

{% highlight java linenos %}
/* RIL.java */
public RIL(Context context, int preferredNetworkType, int cdmaSubscription, Integer instanceId) {
    // ...
    mSenderThread = new HanlderThread("RILSender" + mInstanceId);
    mSenderThread.start();

    Looper looper = mSenderThread.getLooper();
    mSender =  new RILSender(looper);
    // ...
}
{% endhighlight %}

RILSender接收RIL发送的Message对象后在handleMessage方法中处理RILRequest对象，然后利用RILReceiver创建的LocalSocket对象把RIL req数据发送给RIL守护进程。

{% highlight java linenos %}
/* RIL.java */
class RILSender extends Handler implements Runnable {
    public RILSender(Looper looper) {
        super(looper);
    }

    @Override
    public void handleMessage(Message msg) {
        // 从Message对象取RILRequest对象
        RILRequest rr = (RILRequest)(msg.obj);
        // ...

        switch (msg.what) {
            case EVENT_SEND:
                try {
                    LocalSocket s;
                    // mSocket为RILReceiver创建的LocalSocket对象
                    s = mSocket;
                    // ...
                    byte[] data;
                    // 对Parcel对象编组，以便用Socket发送给RILC
                    data = rr.mParcel.marshall();
                    // 把RILRequest对象加入到RILRequest List，以便RIL resp服务查找
                    synchronized (mRequestList) {
                        mRequestList.append(rr.mSerial, rr);
                        rr.mParcel.recycle();
                        rr.mParcel = null;
                    }
                    // ...
                    // parcel length in big endan
                    dataLength[0] = dataLength[1] = 0;
                    dataLength[2] = (byte)((data.length >> 8) & 0xff);
                    dataLength[3] = (byte)((data.length) & 0xff);

                    // 发送给RIL守护进程
                    s.getOutputStream().write(dataLength);
                    s.getOutputStream().write(data);
                } // catch ...
                break;
            // ...
        }
    }
}
{% endhighlight %}

### 4. RILReceiver接收RIL守护进程发送的结果，处理后发送给客户端的Handler

首先从socket中读取数据，然后根据类型（resp服务或ind服务）处理。从mRequestList中根据serial值取出RILRequest对象并删除。然后从RILRequest对象中取出客户端的Message对象，把rild返回的数据存到Message对象中，然后发送给客户端来处理返回的数据。

{% highlight java linenos %}
/* RIL.java */
class RILReceiver implements Runnable {
    byte[] buffer;
    // ...
    @Override
    public void
    run() {
        //...
        try {
            // 连接rild的socket
            s = new LocalSocket();
            l = new LocalSocketAddress(rilSocket,
                    LocalSocketAddress.Namespace.RESERVED);
            s.connect(l);
        } catch (IOException ex){
            // ...
        }
        // 把socket保存到mSocket成员变了，共RILSender调用
        mSocket = s;
        // ...
        int length = 0;
        try {
            InputStream is = mSocket.getInputStream();
            for (;;) {
                Parcel p;
                // 从socket中读取数据存到buffer
                length = readRilMessage(is, buffer);
                if (length < 0) {
                    // End-of-stream reached
                    break;
                }
                // 把数据反编组保存到Parcel对象中
                p = Parcel.obtain();
                p.unmarshall(buffer, 0, length);
                p.setDataPosition(0);

                //Rlog.v(RILJ_LOG_TAG, "Read packet: " + length + " bytes");
                // 处理数据
                processResponse(p);
                p.recycle();
            }
        } // catch {}
        // ...
    }
}

private void processResponse (Parcel p) {
    int type;
    type = p.readInt();
    if (type == RESPONSE_UNSOLICITED) {
        // 处理ind服务，即rild自发发送的数据
        processUnsolicited (p);
    } else if (type == RESPONSE_SOLICITED) {
        // 处理resp服务，即请求rild后返回的数据
        RILRequest rr = processSolicited (p);
        if (rr != null) {
            rr.release();
            decrementWakeLock();
        }
    }
}

private RILRequest processSolicited (Parcel p) {
    int serial, error;
    boolean found = false;

    serial = p.readInt();
    error = p.readInt();

    RILRequest rr;
    // 在mRequestList中取出RILRequest对象，然后删除
    rr = findAndRemoveRequestFromList(serial);
    // ...
    if (error == 0 || p.dataAvail() > 0) {
        try {switch (rr.mRequest) {
        // ...
        // responseVoid方法中直接返回null
        case RIL_REQUEST_DIAL: ret =  responseVoid(p); break;
        // ...
        }} // catch {}
    }
    // ...
    if (error == 0) {
        if (rr.mResult != null) {
            // 处理RILRequest对象的数据
            // 用AsyncResult对象包一下m.obj和ret然后再赋给m.obj
            /*
            public static AsyncResult
            forMessage(Message m, Object r, Throwable ex) {
                AsyncResult ret;
                ret = new AsyncResult (m.obj, r, ex);
                m.obj = ret;
                return ret;}
            */
            AsyncResult.forMessage(rr.mResult, ret, null);
            // 发送给客户端的Handler对象来处理
            rr.mResult.sendToTarget();
        }
    }
    return rr;
}
{% endhighlight %}

### 5. 客户端的Handler对象根据Message对象类型处理结果

GsmCallTracker对象处理返回的Message对象

{% highlight java linenos %}
/* GsmCallTracker.java */
@Override
public void handleMessage (Message msg) {
    AsyncResult ar;
    // ...
    switch (msg.what) {
        // ...
        case EVENT_DIAL_CALL_RESULT:
            ar = (AsyncResult) msg.obj;
            if (ar.exception != null) {
                log("dial call failed!!");
                mHelper.PendingHangupRequestUpdate();
            }
            operationComplete();
        break;
        // ...
    }
}
{% endhighlight %}

RILJ的req/resp服务的整个流程如下图所示。
<figure>
    <a href="/images/RIL_req_resp.png"><img src="/images/RIL_req_resp.png" alt="RIL req/resp"></a>
    <figcaption>RIL req/resp service</figcaption>
</figure>

to be continued...
